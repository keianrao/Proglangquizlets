<!doctype html>
<!--
You know.. Always using the browser to run our JavaScript code like this.
Reminds me of how people ran Java back then. Apparently their browser's was
the only JVM they had - and they were well-optimised for applets apparently.
-->
<html>
	
	<meta charset="utf-8">
	
	<textarea id="output" disabled=true>This is a JavaScript app.</textarea>
	
	<style>
		html { width: 100%; height: 100%; }
		body { height: 100%; margin: 0; }
		#output {
			width: 100%; height: 100%;
			border: none; padding: 0; margin: 0;
			resize: none;
			font-size: 18pt;
			color: black;
			background: #EEE;
		}
	</style>
	
	<script>
		const output = document.getElementById("output");
		
		output.textContent = "";
		output.log = function(text) {
			if (this.textContent.length !== 0)
				this.textContent += "\n";
			
			this.textContent += text;
		}
		
		
		
		//  Tests   \\  //  \\  //  \\  //  \\  //  \\  //  \\  //  \\
		
		function isInOrder(array, orderTestFunction)
		{
			if (array.length === 0) return true;
			
			var [previous, ...rest] = array;
			for (var current of rest) {
				if (!orderTestFunction(previous, current)) return false;
				previous = current;
			}
			
			return true;
		}
		
		function isSortedByX(arrayOfPoints) {
			return isInOrder(
				arrayOfPoints.map((point) => point.x),
				(previousX, currentX) => previousX < currentX
			);
		}
		
		function isContinuousOverX(arrayOfPoints) {
			return isInOrder(
				arrayOfPoints.map((point) => point.x),
				(previousX, currentX) => currentX == previousX + 1
			);
		}
		
		function isThirdSmallestY(y, arrayOfPoints) {
			function getSortedUniqueYs(arrayOfPoints) {
				function shallowCopyArray(array) {
					return array.slice();
				}
				var sortedYs = 
					shallowCopyArray(arrayOfPoints)
						.map((point) => point.y)
						.sort((previousY, currentY) => previousY > currentY);
				// Apparently the parser looks forward before
				// auto-inserting a terminating semicolon.

				// We will manually remove duplicates..
				var [previousY, ...rest] = sortedYs;
				var sortedUniqueYs = [previousY];
				for (var currentY of rest) {
					if (currentY == previousY) continue;
					sortedUniqueYs.push(currentY);
					previousY = currentY;
				}
				
				return sortedUniqueYs;
			}
			
			var sortedUniqueYs = getSortedUniqueYs(arrayOfPoints);

			if (sortedUniqueYs.length < 3) return false;
			return y == sortedUniqueYs[2];
		}
		
		function isValidBinaryTree(root) {
			// We can represent binary trees as arrays.. but we aren't
			// using C. We'll take the performance hit.
			
			if (root == null) return true;
			
			if (root.left != null && root.left.value > root.value)
				return false;
							
			if (root.right != null && root.right.value < root.value)
				return false;
				
			return (
				isValidBinaryTree(root.left)
				&& isValidBinaryTree(root.right)
			);
		}
		
		function isCorrectTraversal(finalNodeValue, path, tree) {
		
		}
		
		function testIsSortedByX() {
			var normalSorted = [
				{ x: 1, y: 4 },
				{ x: 2, y: 8 },
				{ x: 4, y: 20 },
				{ x: 5, y: 1 }
			];
			if (!isSortedByX(normalSorted)) {
				output.log("Failed on 'normal sorted' case!");
				return false;
			}
			
			var normalUnsorted = [
				{ x: 2, y: 10 },
				{ x: 3, y: 6 },
				{ x: 1, y: 0 }
			];
			if (isSortedByX(normalUnsorted)) {
				output.log("Failed on 'normal unsorted' case!");
				return false;
			}
			
			if (!isSortedByX([])) {
				output.log("Failed on 'empty' case!");
				return false;
			}
			
			return true;
		}
		
		function testIsContinuousOverX() {
			var normalContinuous = [
				{ x: 4, y: 5 },
				{ x: 5, y: 7 },
				{ x: 6, y: 10 },
			];
			if (!isContinuousOverX(normalContinuous)) {
				output.log("Failed on 'normal continuous' case!");		
				return false;
			}
			
			var normalDiscontinuous = [
				{ x: 4, y: 1 },
				{ x: 5, y: 2 },
				{ x: 7, y: 3 }
			];
			if (isContinuousOverX(normalDiscontinuous)) {
				output.log("Failed on 'normal discontinuous' case!");
				return false;
			}
			
			if (!isContinuousOverX([])) {
				output.log("Failed on 'empty' case!");
				return false;
			}
			
			return true;
		}
		
		function testIsThirdSmallestY() {
			var normalCorrect = [
				{ x: 1, y: 7 },
				{ x: 2, y: 10 },
				{ x: 3, y: 20 },
				{ x: 0, y: 40 }
			];
			if (!isThirdSmallestY(20, normalCorrect)) {
				output.log("Failed on 'normal correct' case!");
				return false;
			}
			
			var normalIncorrect = [
				{ x: 4, y: 60 },
				{ x: 3, y: 60 },
				{ x: 2, y: 20 },
				{ x: 1, y: 20 },				
				{ x: 0, y: 0 },
			];
			if (isThirdSmallestY(20, normalIncorrect)) {
				output.log("Failed on 'normal incorrect' case!");
				return false;
			}
			if (!isThirdSmallestY(60, normalIncorrect)) {
				output.log("Failed on 'two corrects' case!");
				return false;
			}
			
			return true;
		}
		
		function testIsValidBinaryTree() {
			var normalValid = {
				value: 5,
				left: {
					value: 3,
					left: null,
					right: {
						value: 4,
						left: null,
						right: null
					}
				},
				right: {
					value: 8,
					left: {
						value: 6,
						left: null,
						right: {
							value: 7,
							left: null,
							right: null
						}
					},
					right: {
						value: 10,
						left: null,
						right: null
					}
				}
			};
			if (!isValidBinaryTree(normalValid)) {
				output.log("Failed on 'normal valid' case!");		
				return false;
			}
			
			var normalInvalid = {
				value: 100,
				left: {
					value: 80,
					left: null,
					right: null
				},
				right: {
					value: 20,
					left: null,
					right: null
				}
			}
			if (isValidBinaryTree(normalInvalid)) {
				output.log("Failed on 'normal invalid' case!");
				return false;
			}
			
			var singleNodeValid = {
				value: 0,
				left: null,
				right: null
			}
			if (!isValidBinaryTree(singleNodeValid)) {
				output.log("Failed on 'single node' case!")
				return false;
			}
			
			var lateInvalid = {
				value: 10,
				left: {
					value: 5,
					left: {
						value: 3,
						left: {
							value: 1,
							left: null,
							right: null
						},
						right: {
							value: 4,
							left: null,
							right: null
						}
					},
					right: null
				},
				right: {
					value: 20,
					left: {
						value: 16,
						left: null,
						right: {
							value: 18,
							left: {
								value: 19,
								left: null,
								right: null
							},
							right: null
						}
					},
					right: null
				}
			}
			if (isValidBinaryTree(lateInvalid)) {
				output.log("Failed on 'late invalid' case!");
				return false;
			}
			
			return true;
		}
		
		function testIsCorrectTraversal() {
					
		}
		
		function testAllAsserts() {
			// We test the functions that rely on isInOrder,
			// so we'll treat isInOrder as tested by proxy.
		
			if (!testIsSortedByX()) {
				output.log("isSortedByX is not functioning correctly!");
				return false;
			}
			
			if (!testIsContinuousOverX()) {
				output.log("isContinuousOverX is not functioning correctly!");
				return false;
			}
			
			if (!testIsThirdSmallestY()) {
				output.log("isThirdSmallestY is not functioning correctly!");
				return false;
			}
			
			if (!testIsValidBinaryTree()) {
				output.log("isValidBinaryTree is not functioning correctly!");
				return false;
			}
			
			return true;
		}
		
		
		
		//  Main    \\  //  \\  //  \\  //  \\  //  \\  //  \\  //  \\
		
		function perform(points) {
			
		}
		
		if (!testAllAsserts()) {
			output.log("Stopping.");
		}
		else {
			perform([
				{ x: 10, y: 0 },
				{ x: 1, y: 20 },
				{ x: 15, y: 23 },
				{ x: 4, y: 30 },
				{ x: 8, y: 16 },
				{ x: 17, y: 5 },
				{ x: 3, y: 3 },
				{ x: 0, y: 4 }
			]);
		}
	</script>
	
</html>
