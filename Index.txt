Problem 1
---
Given a list of 2D points, of integer coordinates,
(1) Sort them by X;

(2) For any (integer) X with no point covering it, make one up using linear interpolation on the existing points. (As in, the nearest existing point to its left and right, draw a straight line between them and use that line to plot points over the uncovered Xes).

(3) Find and record the third-smallest Y value amongst the new list of points.

(4) Assemble the new list of points into a (sorted) binary tree with the points' Y's as values.

(5) Binary search for the recorded third-smallest Y value, recording the values of the nodes you visited along the way (including the root).

This is some really cheesy algorithms problems, but let's see if you can survive what is basically five separate ones in a row.

Implementation language: JavaScript

%%

Problem 2
---
(1) Store hierarchical data in the form of nested dictionaries. For example, for every mapping in a given dictionary, might be an atomic value, or another dictionary.

(2) Print every atomic value in the dictionary to standard output, as its own line of the form 'K = V' - where K is the (corresponding) key's name, preceded by the key names of the nested dictionaries it is in, separated by periods.

This is better explained with an example. Suppose a top-level dictionary has two mappings: 'first' to '5'; and 'second' to another dictionary, which contains one mapping 'a' to 'A'.

    {
        first: 5
        second: {
            a: A
        }
    }

Then, to print this dictionary as per the question.

    first = 5
    second.a = A

There was no entry for 'second' as a key since it didn't map to an atomic value, but the atomic value inside it was printed prefixed by 'second.', since 'second' is the key name of a nested dictionary it was in, so we wrote that and a separating period. Here are some more examples:

    third = 10
    fourth.first = 10
    fourth.second.first = 10

    value = 2
    left.value = 1
    right.value = 3

    fruits.tropical.green = durian

Hopefully this terrible, long-winded explanation gives the idea.

Anyhow. So, nested dictionary. Print each atomic value as a 'K = V' line, where if it's nested then prefix the K appropriately.


(3) Repeat (1), but this time in the form of some sort of object with a custom type/class.

(4) Print the object in (3), overriding its string representation such that it matches what (2) does.

For this step to make sense, the print function you are using needs to somehow let you provide the string representation for the object. For example, in OO languages, usually the print function calls some public method of the object that you can override.

Implementation language: Python

%%
